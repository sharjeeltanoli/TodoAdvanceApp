# Implementation Plan: Full-Stack Todo CRUD Application

**Branch**: `001-todo-crud` | **Date**: 2026-02-09 | **Spec**: [specs/001-todo-crud/spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-todo-crud/spec.md`

## Summary

Build a full-stack todo application with authenticated CRUD operations. Next.js 16 (App Router, TypeScript, Tailwind CSS) serves as the frontend and auth server via Better Auth. FastAPI (Python 3.13, SQLModel, async) serves as the backend REST API. Neon Serverless PostgreSQL is the shared database. All task operations require JWT Bearer authentication and enforce per-user data isolation at the service layer.

---

## Technical Context

**Language/Version**: TypeScript 5.x (frontend), Python 3.13 (backend)
**Primary Dependencies**: Next.js 16, Better Auth, Tailwind CSS 4, FastAPI, SQLModel, Alembic, asyncpg
**Storage**: Neon Serverless PostgreSQL (shared by auth and app)
**Testing**: Vitest (frontend), pytest + httpx (backend)
**Target Platform**: Web (desktop + mobile responsive, 375px–1920px)
**Project Type**: Web application (frontend + backend monorepo)
**Performance Goals**: Task list loads <2s for 500 tasks; toggle completion reflects <1s
**Constraints**: <200ms p95 API response; all queries filtered by `user_id`
**Scale/Scope**: Single-user focus; no multi-device sync required

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-checked after Phase 1 design.*

| # | Principle | Status | Evidence |
|---|-----------|--------|----------|
| I | Spec-Driven Development | PASS | spec.md, plan.md, research.md, data-model.md all exist before implementation |
| II | Monorepo Structure | PASS | `frontend/` and `backend/` top-level directories; shared config at root |
| III | Stateless Services | PASS | All state in Neon PostgreSQL; FastAPI has no in-memory state between requests |
| IV | Event-Driven Architecture | N/A | Kafka/Dapr not required until Phase 5; no async inter-service communication in Phase 2 |
| V | User Isolation | PASS | Every query filters by `user_id` from JWT; 404 (not 403) for cross-user access |
| VI | MCP Protocol | N/A | MCP not required until Phase 3 (AI Chatbot) |

**Security Requirements Check:**

| Requirement | Status | Evidence |
|-------------|--------|----------|
| JWT auth on all endpoints | PASS | Bearer token required; `get_current_user` dependency on every route |
| `Authorization: Bearer` header | PASS | FastAPI verifies via Better Auth session validation |
| User-scoped data filtering | PASS | `user_id` filter in every SQL query at service layer |
| No hardcoded secrets | PASS | All secrets via `.env` files; `.env.example` templates provided |
| CORS restricted | PASS | `CORS_ORIGINS` env var; wildcard only in dev |
| Pinned dependencies | PASS | `pip freeze` / `package-lock.json` with exact versions |

**Gate result: PASS — no violations.**

---

## 1. Monorepo Folder Structure

### Documentation (this feature)

```text
specs/001-todo-crud/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Phase 0 research decisions
├── data-model.md        # Entity schemas and relationships
├── quickstart.md        # Local dev setup guide
├── contracts/
│   └── api.yaml         # OpenAPI 3.1 contract
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
hackathon-todo/
├── frontend/                          # Next.js 16 application
│   ├── package.json
│   ├── package-lock.json
│   ├── next.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.ts
│   ├── postcss.config.mjs
│   ├── .env.example
│   ├── .env.local                     # (gitignored) local secrets
│   ├── public/
│   │   └── favicon.ico
│   ├── src/
│   │   ├── app/                       # App Router pages
│   │   │   ├── layout.tsx             # Root layout (html, body, providers)
│   │   │   ├── page.tsx               # Landing: redirect to /dashboard or /login
│   │   │   ├── login/
│   │   │   │   └── page.tsx           # Login form
│   │   │   ├── signup/
│   │   │   │   └── page.tsx           # Registration form
│   │   │   └── dashboard/
│   │   │       ├── layout.tsx         # Authenticated layout (nav, logout)
│   │   │       ├── page.tsx           # Task list + CRUD operations
│   │   │       └── actions.ts         # Server Actions for task operations
│   │   ├── components/
│   │   │   ├── auth/
│   │   │   │   ├── login-form.tsx     # Client component: email/password login
│   │   │   │   └── signup-form.tsx    # Client component: registration form
│   │   │   ├── tasks/
│   │   │   │   ├── task-list.tsx      # Client component: renders list of tasks
│   │   │   │   ├── task-item.tsx      # Client component: single task row
│   │   │   │   ├── task-form.tsx      # Client component: create/edit task form
│   │   │   │   ├── delete-dialog.tsx  # Client component: confirmation modal
│   │   │   │   └── empty-state.tsx    # Display when no tasks exist
│   │   │   └── ui/
│   │   │       ├── button.tsx         # Reusable button component
│   │   │       ├── input.tsx          # Reusable input component
│   │   │       └── error-message.tsx  # Inline validation error display
│   │   ├── lib/
│   │   │   ├── auth.ts               # Better Auth server instance
│   │   │   ├── auth-client.ts         # Better Auth client instance
│   │   │   └── api.ts                 # Server-side FastAPI client (fetch wrapper)
│   │   └── proxy.ts                   # Next.js 16 proxy (auth redirect logic)
│   └── tests/
│       ├── components/
│       └── e2e/
│
├── backend/                           # FastAPI application
│   ├── pyproject.toml                 # Python project config + dependencies
│   ├── alembic.ini                    # Alembic migration config
│   ├── .env.example
│   ├── .env                           # (gitignored) local secrets
│   ├── alembic/
│   │   ├── env.py                     # Migration environment
│   │   └── versions/                  # Migration files
│   │       └── 001_create_task_table.py
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                    # FastAPI app factory, CORS, lifespan
│   │   ├── config.py                  # Pydantic Settings (env var loading)
│   │   ├── database.py                # Async engine, session factory
│   │   ├── models.py                  # SQLModel: Task table + Pydantic schemas
│   │   ├── dependencies.py            # get_current_user (Bearer token -> user_id)
│   │   └── routes/
│   │       ├── __init__.py
│   │       └── todos.py               # CRUD endpoints: /api/todos
│   └── tests/
│       ├── conftest.py                # Fixtures: test client, test DB, auth mock
│       ├── test_todos.py              # CRUD endpoint tests
│       └── test_auth.py               # Auth middleware tests
│
├── .gitignore
├── CLAUDE.md
└── README.md
```

**Structure Decision**: Web application monorepo with `frontend/` and `backend/` top-level directories per Constitution Principle II. Shared Neon database; no shared code packages needed in Phase 2.

---

## 2. Database Schema

### Shared Database: Neon Serverless PostgreSQL

One Neon database serves both Better Auth (auth tables) and FastAPI (app tables). Better Auth creates its tables via `npx @better-auth/cli migrate`. FastAPI manages the `task` table via Alembic.

### Tables Managed by Better Auth

| Table | Owner | Purpose |
|-------|-------|---------|
| `user` | Better Auth | User accounts (id, name, email, emailVerified, image, timestamps) |
| `session` | Better Auth | Active sessions (token, userId, expiresAt, ipAddress, userAgent) |
| `account` | Better Auth | Auth providers + password hashes |
| `verification` | Better Auth | Email verification tokens |
| `jwks` | Better Auth (JWT plugin) | JWT signing key pairs |

### Table: `task` (FastAPI-managed via Alembic)

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE task (
    id          UUID         PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id     TEXT         NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    title       VARCHAR(255) NOT NULL,
    description TEXT,
    completed   BOOLEAN      NOT NULL DEFAULT FALSE,
    created_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

CREATE INDEX ix_task_user_id      ON task (user_id);
CREATE INDEX ix_task_user_created ON task (user_id, created_at DESC);
```

### SQLModel Definition (backend/app/models.py)

```python
import uuid
from datetime import datetime
from sqlmodel import SQLModel, Field
from pydantic import field_validator

class TaskBase(SQLModel):
    title: str = Field(max_length=255, min_length=1)
    description: str | None = Field(default=None, max_length=2000)

    @field_validator("title")
    @classmethod
    def title_not_whitespace(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Title cannot be empty or whitespace-only")
        return v.strip()

class TaskCreate(TaskBase):
    pass

class TaskUpdate(SQLModel):
    title: str | None = Field(default=None, max_length=255, min_length=1)
    description: str | None = Field(default=None, max_length=2000)

    @field_validator("title")
    @classmethod
    def title_not_whitespace(cls, v: str | None) -> str | None:
        if v is not None and not v.strip():
            raise ValueError("Title cannot be empty or whitespace-only")
        return v.strip() if v else v

class Task(TaskBase, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    user_id: str = Field(index=True, nullable=False)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class TaskResponse(TaskBase):
    id: uuid.UUID
    completed: bool
    created_at: datetime
    updated_at: datetime
```

### Validation Rules

| Field | Rule | Enforced At |
|-------|------|-------------|
| `title` | Required, 1-255 chars, no whitespace-only | Frontend + Backend |
| `description` | Optional, max 2000 chars | Frontend + Backend |
| `completed` | Boolean | Backend (toggle endpoint) |
| `user_id` | Must match JWT-authenticated user | Backend (dependency injection) |

---

## 3. API Contracts

**Base URL**: `http://localhost:8000`
**Auth**: All endpoints require `Authorization: Bearer <token>` header
**Content-Type**: `application/json`
**Full OpenAPI spec**: [`contracts/api.yaml`](./contracts/api.yaml)

### Endpoint Summary

| Method | Path | Operation | Status Codes |
|--------|------|-----------|--------------|
| GET | `/api/todos` | List all tasks for authenticated user | 200, 401 |
| POST | `/api/todos` | Create a new task | 201, 401, 422 |
| GET | `/api/todos/{task_id}` | Get a specific task | 200, 401, 404 |
| PUT | `/api/todos/{task_id}` | Update task title/description | 200, 401, 404, 422 |
| DELETE | `/api/todos/{task_id}` | Delete a task permanently | 204, 401, 404 |
| PATCH | `/api/todos/{task_id}/complete` | Toggle completion status | 200, 401, 404 |

### 3.1 List Tasks: `GET /api/todos`

**Request**:
```http
GET /api/todos HTTP/1.1
Authorization: Bearer <token>
```

**Response** `200 OK`:
```json
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "Buy groceries",
    "description": "Milk, bread, eggs",
    "completed": false,
    "created_at": "2026-02-08T10:30:00Z",
    "updated_at": "2026-02-08T10:30:00Z"
  }
]
```

**Behavior**: Returns all tasks where `user_id` matches authenticated user. Ordered by `created_at DESC` (newest first). Returns empty array `[]` if no tasks.

---

### 3.2 Create Task: `POST /api/todos`

**Request**:
```http
POST /api/todos HTTP/1.1
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "Buy groceries",
  "description": "Milk, bread, eggs"
}
```

**Response** `201 Created`:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "Buy groceries",
  "description": "Milk, bread, eggs",
  "completed": false,
  "created_at": "2026-02-08T10:30:00Z",
  "updated_at": "2026-02-08T10:30:00Z"
}
```

**Response** `422 Unprocessable Entity` (validation):
```json
{
  "detail": [
    { "loc": ["body", "title"], "msg": "String should have at least 1 character", "type": "string_too_short" }
  ]
}
```

**Behavior**: Sets `user_id` from JWT token (never from request body). Sets `completed=false`, generates UUID, sets timestamps.

---

### 3.3 Get Task: `GET /api/todos/{task_id}`

**Request**:
```http
GET /api/todos/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer <token>
```

**Response** `200 OK`: Same shape as TaskResponse above.

**Response** `404 Not Found` (task does not exist OR belongs to another user):
```json
{ "detail": "Task not found" }
```

**Behavior**: Queries by both `id` AND `user_id` to prevent IDOR. Returns 404 (not 403) to avoid leaking existence of other users' tasks.

---

### 3.4 Update Task: `PUT /api/todos/{task_id}`

**Request**:
```http
PUT /api/todos/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "Buy organic groceries",
  "description": "Organic milk, sourdough bread"
}
```

**Response** `200 OK`: Returns full updated TaskResponse.

**Behavior**: Partial update — only provided fields are modified. `updated_at` is refreshed. Title validation applies if provided.

---

### 3.5 Delete Task: `DELETE /api/todos/{task_id}`

**Request**:
```http
DELETE /api/todos/550e8400-e29b-41d4-a716-446655440000 HTTP/1.1
Authorization: Bearer <token>
```

**Response** `204 No Content`: Empty body.

**Behavior**: Hard delete. Confirmation dialog is client-side only. Queries by `id` AND `user_id`.

---

### 3.6 Toggle Completion: `PATCH /api/todos/{task_id}/complete`

**Request**:
```http
PATCH /api/todos/550e8400-e29b-41d4-a716-446655440000/complete HTTP/1.1
Authorization: Bearer <token>
```

**Response** `200 OK`: Returns full updated TaskResponse with toggled `completed` value.

**Behavior**: Flips `completed` boolean. Updates `updated_at`. No request body needed.

---

## 4. Authentication Flow

### Architecture Overview

```
Browser                   Next.js 16                  FastAPI
  |                      (Auth Server)              (Resource API)
  |                          |                          |
  |-- Better Auth Client --> |                          |
  |   signUp / signIn        |                          |
  |                          |-- Creates user/session -->|
  |<-- Session cookie -------|                          |
  |                          |                          |
  |-- Page request --------->|                          |
  |                          |-- proxy.ts: cookie? ---->|
  |                          |-- Server Action:         |
  |                          |   getSession() --------->|
  |                          |   Bearer token --------->|-- validates token
  |                          |                          |-- filters by user_id
  |                          |<-- task data ------------|
  |<-- rendered page --------|                          |
```

### Step-by-Step: Registration

1. User submits email + password on `/signup` page
2. Better Auth client (`authClient.signUp.email()`) sends `POST /api/auth/sign-up/email`
3. Better Auth creates `user` + `account` (hashed password) + `session` records
4. Session cookie is set in the browser automatically
5. User is redirected to `/dashboard`

### Step-by-Step: Login

1. User submits email + password on `/login` page
2. Better Auth client (`authClient.signIn.email()`) sends `POST /api/auth/sign-in/email`
3. Better Auth validates credentials, creates a new `session` record
4. Session cookie is set in the browser
5. User is redirected to `/dashboard`

### Step-by-Step: Authenticated API Request

1. **proxy.ts** (runs on every request): Checks for session cookie existence. If missing, redirects to `/login`. Does NOT do full token validation (defense in depth — not the sole gate).
2. **Server Component / Server Action**: Calls `auth.api.getSession()` with request headers to get the active session. Extracts the session token.
3. **Server Action** forwards request to FastAPI with `Authorization: Bearer <session-token>` header.
4. **FastAPI `get_current_user` dependency**: Receives the Bearer token, calls Better Auth's `GET /api/auth/get-session` on Next.js to validate and get `user_id`.
5. **FastAPI route**: Uses the verified `user_id` to filter all database queries.

### Token Verification in FastAPI (dependencies.py)

```python
import httpx
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.config import settings

bearer_scheme = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
) -> str:
    """Validate Bearer token via Better Auth and return user_id."""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{settings.BETTER_AUTH_URL}/api/auth/get-session",
            headers={"Authorization": f"Bearer {credentials.credentials}"},
        )
    if response.status_code != 200:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
        )
    session_data = response.json()
    user_id = session_data.get("user", {}).get("id")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid session",
        )
    return user_id
```

### Step-by-Step: Logout

1. User clicks "Log Out" in the dashboard nav
2. Better Auth client (`authClient.signOut()`) sends `POST /api/auth/sign-out`
3. Better Auth deletes the session record and clears the cookie
4. User is redirected to `/login`

### Three-Layer Auth Defense

| Layer | Component | Checks | Failure Action |
|-------|-----------|--------|----------------|
| 1 | `proxy.ts` | Cookie exists? | Redirect to `/login` |
| 2 | Server Actions | Valid session via `auth.api.getSession()`? | Return 401 / redirect |
| 3 | FastAPI | Valid Bearer token via Better Auth? `user_id` present? | Return 401 JSON |

---

## 5. Frontend Architecture

### Next.js 16 App Router

#### Pages

| Route | File | Type | Auth Required | Purpose |
|-------|------|------|---------------|---------|
| `/` | `app/page.tsx` | Server | No | Redirect: authenticated -> `/dashboard`, else -> `/login` |
| `/login` | `app/login/page.tsx` | Server | No | Renders `<LoginForm />` |
| `/signup` | `app/signup/page.tsx` | Server | No | Renders `<SignupForm />` |
| `/dashboard` | `app/dashboard/page.tsx` | Server | Yes | Fetches tasks via Server Action, renders `<TaskList />` |

#### Components

**Auth Components** (`src/components/auth/`):
- `login-form.tsx` — Client Component. Email + password inputs, form validation, calls `authClient.signIn.email()`, handles errors, redirects on success.
- `signup-form.tsx` — Client Component. Email + password inputs, calls `authClient.signUp.email()`, handles duplicate email error, redirects on success.

**Task Components** (`src/components/tasks/`):
- `task-list.tsx` — Client Component. Receives initial tasks as props. Manages local state for optimistic updates. Maps tasks to `<TaskItem />`. Shows `<EmptyState />` when no tasks. Includes `<TaskForm />` for creation.
- `task-item.tsx` — Client Component. Renders a single task row: checkbox (toggle complete), title, description, edit button, delete button. Strikethrough styling when completed.
- `task-form.tsx` — Client Component. Used for both create and edit. Title input (required), description textarea (optional). Client-side validation (non-empty title, max lengths). Calls Server Actions for create/update.
- `delete-dialog.tsx` — Client Component. Confirmation modal: "Are you sure you want to delete this task?" with Cancel and Delete buttons.
- `empty-state.tsx` — Server Component. Friendly message encouraging user to create their first task.

**UI Components** (`src/components/ui/`):
- `button.tsx` — Styled button with variants (primary, danger, ghost).
- `input.tsx` — Styled input with label, error state support.
- `error-message.tsx` — Inline validation error display.

#### Lib

- `auth.ts` — Better Auth server instance. Configures `betterAuth()` with database adapter (Kysely + Neon), email/password plugin, Bearer plugin, JWT plugin. Exports `auth` for server-side use.
- `auth-client.ts` — Better Auth client instance. Configures `createAuthClient()` for browser-side auth operations. Exports `authClient`.
- `api.ts` — Server-side fetch wrapper for FastAPI calls. Automatically attaches `Authorization: Bearer <token>` from the current session. Used by Server Actions only.

#### proxy.ts (formerly middleware.ts in Next.js 16)

```typescript
import { NextRequest, NextResponse } from "next/server";

export function proxy(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const sessionCookie = request.cookies.get("better-auth.session_token");

  // Public routes - allow access
  const publicRoutes = ["/login", "/signup"];
  if (publicRoutes.some((route) => pathname.startsWith(route))) {
    // If already authenticated, redirect to dashboard
    if (sessionCookie) {
      return NextResponse.redirect(new URL("/dashboard", request.url));
    }
    return NextResponse.next();
  }

  // Auth API routes - always allow (Better Auth handles them)
  if (pathname.startsWith("/api/auth")) {
    return NextResponse.next();
  }

  // Protected routes - require session cookie
  if (!sessionCookie) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
```

#### Server Actions Pattern

```typescript
// src/app/dashboard/actions.ts
"use server";

import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { api } from "@/lib/api";
import { revalidatePath } from "next/cache";

export async function getTasks() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");
  return api.get("/api/todos", session.session.token);
}

export async function createTask(formData: FormData) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");
  const result = await api.post("/api/todos", {
    title: formData.get("title") as string,
    description: (formData.get("description") as string) || null,
  }, session.session.token);
  revalidatePath("/dashboard");
  return result;
}

export async function toggleComplete(taskId: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");
  const result = await api.patch(
    `/api/todos/${taskId}/complete`,
    session.session.token
  );
  revalidatePath("/dashboard");
  return result;
}

export async function updateTask(taskId: string, data: { title?: string; description?: string }) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");
  const result = await api.put(`/api/todos/${taskId}`, data, session.session.token);
  revalidatePath("/dashboard");
  return result;
}

export async function deleteTask(taskId: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");
  await api.del(`/api/todos/${taskId}`, session.session.token);
  revalidatePath("/dashboard");
}
```

---

## 6. Backend Architecture

### FastAPI Application Structure

#### `app/main.py` — Application Factory

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.config import settings
from app.database import create_db_and_tables
from app.routes import todos

@asynccontextmanager
async def lifespan(app: FastAPI):
    await create_db_and_tables()
    yield

app = FastAPI(
    title="Hackathon Todo API",
    version="1.0.0",
    lifespan=lifespan,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE"],
    allow_headers=["*"],
)

app.include_router(todos.router, prefix="/api")
```

#### `app/config.py` — Settings

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    BETTER_AUTH_URL: str = "http://localhost:3000"
    CORS_ORIGINS: str = "http://localhost:3000"
    DEBUG: bool = False

    @property
    def cors_origins_list(self) -> list[str]:
        return [origin.strip() for origin in self.CORS_ORIGINS.split(",")]

    @property
    def async_database_url(self) -> str:
        """Ensure URL uses asyncpg driver."""
        url = self.DATABASE_URL
        if url.startswith("postgresql://"):
            url = url.replace("postgresql://", "postgresql+asyncpg://", 1)
        return url

    model_config = {"env_file": ".env"}

settings = Settings()
```

#### `app/database.py` — Async Engine

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlmodel import SQLModel
from app.config import settings

engine = create_async_engine(settings.async_database_url, echo=settings.DEBUG)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)

async def get_session():
    async with async_session() as session:
        yield session
```

#### `app/dependencies.py` — Auth Middleware

```python
import httpx
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.config import settings

bearer_scheme = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
) -> str:
    """Validate Bearer token via Better Auth session endpoint."""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{settings.BETTER_AUTH_URL}/api/auth/get-session",
            headers={
                "Authorization": f"Bearer {credentials.credentials}",
            },
        )
    if response.status_code != 200:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
        )
    data = response.json()
    user_id = data.get("user", {}).get("id")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid session data",
        )
    return user_id
```

#### `app/routes/todos.py` — CRUD Endpoints

```python
import uuid
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import select
from app.database import get_session
from app.dependencies import get_current_user
from app.models import Task, TaskCreate, TaskUpdate, TaskResponse

router = APIRouter(tags=["Tasks"])

@router.get("/todos", response_model=list[TaskResponse])
async def list_todos(
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    result = await db.execute(
        select(Task)
        .where(Task.user_id == user_id)
        .order_by(Task.created_at.desc())
    )
    return result.scalars().all()

@router.post("/todos", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)
async def create_todo(
    data: TaskCreate,
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    task = Task(**data.model_dump(), user_id=user_id)
    db.add(task)
    await db.commit()
    await db.refresh(task)
    return task

@router.get("/todos/{task_id}", response_model=TaskResponse)
async def get_todo(
    task_id: uuid.UUID,
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    result = await db.execute(
        select(Task).where(Task.id == task_id, Task.user_id == user_id)
    )
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

@router.put("/todos/{task_id}", response_model=TaskResponse)
async def update_todo(
    task_id: uuid.UUID,
    data: TaskUpdate,
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    result = await db.execute(
        select(Task).where(Task.id == task_id, Task.user_id == user_id)
    )
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(task, key, value)
    task.updated_at = datetime.utcnow()
    await db.commit()
    await db.refresh(task)
    return task

@router.delete("/todos/{task_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_todo(
    task_id: uuid.UUID,
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    result = await db.execute(
        select(Task).where(Task.id == task_id, Task.user_id == user_id)
    )
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    await db.delete(task)
    await db.commit()

@router.patch("/todos/{task_id}/complete", response_model=TaskResponse)
async def toggle_complete(
    task_id: uuid.UUID,
    user_id: str = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    result = await db.execute(
        select(Task).where(Task.id == task_id, Task.user_id == user_id)
    )
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    task.completed = not task.completed
    task.updated_at = datetime.utcnow()
    await db.commit()
    await db.refresh(task)
    return task
```

---

## 7. Technology Decisions

| Technology | Version | Rationale |
|------------|---------|-----------|
| **Next.js** | 16+ | Constitution mandates it. App Router enables Server Components + Server Actions for BFF pattern. `proxy.ts` replaces old middleware. |
| **TypeScript** | 5.x | Type safety across frontend. Catches API contract mismatches at compile time. |
| **Tailwind CSS** | 4 | Constitution mandates it. Utility-first CSS enables rapid UI development without CSS files. |
| **Better Auth** | Latest | Constitution mandates it. Runs natively in Next.js, supports email/password + Bearer plugin + JWT plugin. Eliminates need for custom auth. |
| **FastAPI** | Latest | Constitution mandates it. Async-native Python web framework. Built-in OpenAPI docs. Pydantic validation. |
| **SQLModel** | Latest | Constitution mandates it. Unifies SQLAlchemy ORM + Pydantic schemas in single model definition. Reduces boilerplate. |
| **asyncpg** | Latest | Non-blocking PostgreSQL driver for FastAPI async handlers. Matches FastAPI's async nature. |
| **Alembic** | Latest | Database migration tool for SQLAlchemy/SQLModel. Supports autogenerate from models. Enables version-controlled schema changes. |
| **Neon PostgreSQL** | Serverless | Constitution mandates it. Serverless means zero infrastructure management. Free tier sufficient for hackathon. Built-in connection pooling. |
| **httpx** | Latest | Async HTTP client for Python. Used by FastAPI to validate Bearer tokens against Better Auth endpoint. |
| **Pydantic Settings** | Latest | Type-safe environment variable loading for FastAPI config. Validates required vars at startup. |
| **Vitest** | Latest | Fast test runner for Next.js/TypeScript. Compatible with React Testing Library. |
| **pytest** | Latest | Standard Python test framework. Works with httpx.AsyncClient for FastAPI testing. |

---

## 8. Development Workflow

### Initial Setup

```bash
# 1. Clone and checkout
git clone <repo-url>
cd hackathon-todo
git checkout 001-todo-crud

# 2. Create Neon database
# Visit https://console.neon.tech -> New Project -> copy connection string

# 3. Backend setup
cd backend
python -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"
cp .env.example .env
# Edit .env: set DATABASE_URL, BETTER_AUTH_URL

# 4. Frontend setup
cd ../frontend
npm install
cp .env.example .env.local
# Edit .env.local: set BETTER_AUTH_SECRET, DATABASE_URL, BACKEND_URL

# 5. Run Better Auth migrations (creates auth tables)
npx @better-auth/cli migrate

# 6. Run Alembic migrations (creates task table)
cd ../backend
source .venv/bin/activate
alembic upgrade head
```

### Daily Development

```bash
# Terminal 1: Backend (auto-reload)
cd backend && source .venv/bin/activate
uvicorn app.main:app --reload --port 8000

# Terminal 2: Frontend (auto-reload)
cd frontend
npm run dev

# Terminal 3: Tests (run as needed)
cd backend && pytest                    # Backend tests
cd frontend && npm test                 # Frontend tests
```

### Database Migrations (when models change)

```bash
cd backend && source .venv/bin/activate
alembic revision --autogenerate -m "describe change"
alembic upgrade head
```

### Key URLs During Development

| Service | URL | Purpose |
|---------|-----|---------|
| Frontend | http://localhost:3000 | Next.js application |
| Backend | http://localhost:8000 | FastAPI server |
| API Docs | http://localhost:8000/docs | Swagger UI |
| Auth Endpoints | http://localhost:3000/api/auth/* | Better Auth routes |
| Neon Console | https://console.neon.tech | Database management |

---

## 9. Security

### JWT/Bearer Token Verification

1. **Token Source**: Better Auth issues session tokens on login. The Bearer plugin exposes them via `Authorization: Bearer <token>` header.
2. **Token Validation**: FastAPI's `get_current_user` dependency calls Better Auth's `/api/auth/get-session` endpoint with the Bearer token. This validates the session is active and returns the user object.
3. **User ID Extraction**: The `user_id` is extracted from the validated session response (`response.user.id`), never from the request body or URL path.
4. **Every Endpoint Protected**: All routes in `routes/todos.py` use `Depends(get_current_user)`, making auth mandatory.

### User Isolation (Constitution Principle V)

Every database query MUST include a `user_id` filter. This is enforced at the route handler level:

```python
# CORRECT: always filter by user_id
select(Task).where(Task.id == task_id, Task.user_id == user_id)

# NEVER: querying by task_id alone is a SECURITY VIOLATION
select(Task).where(Task.id == task_id)
```

**Key security behaviors**:
- Cross-user access returns `404 Not Found` (not `403 Forbidden`) to prevent leaking task existence
- `user_id` comes exclusively from the verified JWT, never from URL parameters or request body
- No `/api/{user_id}/tasks` pattern: eliminates IDOR attack surface (see R-006)

### Frontend Auth Layers

| Layer | What It Does | What It Prevents |
|-------|-------------|------------------|
| `proxy.ts` | Cookie-existence check, redirect | Unauthenticated page rendering |
| Server Actions | Full session validation via `auth.api.getSession()` | Stale/invalid sessions |
| FastAPI | Independent Bearer token validation + `user_id` filtering | Bypassed frontend, direct API access |

### Input Validation

- **Client-side**: Immediate feedback for title required, max lengths (255/2000)
- **Server-side**: Pydantic/SQLModel validators enforce all constraints. Whitespace-only titles rejected.
- **SQL Injection**: Prevented by SQLModel/SQLAlchemy parameterized queries (no raw SQL)
- **XSS**: React auto-escapes rendered content. No `dangerouslySetInnerHTML`.

---

## 10. Environment Variables and CORS Configuration

### Backend (`backend/.env`)

```env
# Database (Neon Serverless PostgreSQL)
DATABASE_URL=postgresql+asyncpg://user:password@ep-xxx.region.aws.neon.tech/neondb?sslmode=require

# Better Auth server URL (for token validation)
BETTER_AUTH_URL=http://localhost:3000

# CORS allowed origins (comma-separated)
CORS_ORIGINS=http://localhost:3000

# Debug mode (enables SQL echo, detailed errors)
DEBUG=true
```

### Frontend (`frontend/.env.local`)

```env
# Better Auth secret (generate: openssl rand -base64 32)
BETTER_AUTH_SECRET=<random-32-byte-base64-string>

# Better Auth base URL (must match the running frontend URL)
BETTER_AUTH_URL=http://localhost:3000

# Database URL for Better Auth Kysely adapter (standard pg format, NOT asyncpg)
DATABASE_URL=postgresql://user:password@ep-xxx.region.aws.neon.tech/neondb?sslmode=require

# Public URL for client-side redirects
NEXT_PUBLIC_API_URL=http://localhost:3000

# Backend URL (server-side only, never exposed to browser)
BACKEND_URL=http://localhost:8000
```

### CORS Configuration

```python
# backend/app/main.py
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,  # From CORS_ORIGINS env var
    allow_credentials=True,                     # Allow cookies/auth headers
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE"],
    allow_headers=["*"],                        # Accept Authorization header
)
```

| Environment | `CORS_ORIGINS` Value | Notes |
|-------------|---------------------|-------|
| Local dev | `http://localhost:3000` | Only the frontend origin |
| Production | `https://your-domain.com` | Exact production domain |
| Never | `*` | Constitution prohibits wildcard in production |

### `.env.example` Files

Both `backend/.env.example` and `frontend/.env.example` are committed to git with placeholder values. Actual `.env` and `.env.local` files are gitignored.

### Environment Variable Validation

- **Backend**: Pydantic Settings validates all required vars at startup. Missing `DATABASE_URL` crashes immediately with clear error.
- **Frontend**: Next.js validates `NEXT_PUBLIC_*` vars at build time. Server-only vars validated at runtime.

---

## Complexity Tracking

> No Constitution Check violations. Table not needed.

---

## Follow-ups and Risks

1. **Risk: Better Auth Bearer plugin maturity** — The Bearer plugin is newer. If token validation via `/api/auth/get-session` has latency issues, consider caching validated sessions in FastAPI with a short TTL (30s).
2. **Risk: Neon cold starts** — Serverless PostgreSQL may have cold-start latency on first request. Mitigate with Neon's `pooler` connection string mode and connection keep-alive.
3. **Follow-up: Run `/sp.tasks` to generate implementation task breakdown** — This plan provides the architectural foundation; the tasks file will define the step-by-step implementation order with test cases for each task.
